"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5429],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),d=r,h=u["".concat(l,".").concat(d)]||u[d]||m[d]||o;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6495:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return m}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],s={title:"Reactive Programming"},l=void 0,p={unversionedId:"reactive-programming",id:"reactive-programming",title:"Reactive Programming",description:"Reactive programming is a declarative programming paradigm that handles asynchronous workflows in data streams.",source:"@site/docs/reactive-programming.md",sourceDirName:".",slug:"/reactive-programming",permalink:"/docs/reactive-programming",draft:!1,editUrl:"https://github.com/machinat/sociably/edit/master/website/docs/reactive-programming.md",tags:[],version:"current",frontMatter:{title:"Reactive Programming"},sidebar:"docs",previous:{title:"Embedded Webview",permalink:"/docs/embedded-webview"},next:{title:"Messenger",permalink:"/docs/messenger-platform"}},c={},m=[{value:"Sociably Stream Package",id:"sociably-stream-package",level:2},{value:"Install",id:"install",level:3},{value:"Usage",id:"usage",level:2},{value:"Root Stream From App",id:"root-stream-from-app",level:3},{value:"Listen to a Stream",id:"listen-to-a-stream",level:3},{value:"Pipe to a New Stream",id:"pipe-to-a-new-stream",level:3},{value:"Filter a Stream",id:"filter-a-stream",level:3},{value:"Map a Stream",id:"map-a-stream",level:3},{value:"Execute a Side Effect",id:"execute-a-side-effect",level:3},{value:"Use Asynchronized Container",id:"use-asynchronized-container",level:3},{value:"Merge Streams",id:"merge-streams",level:3},{value:"Constraints and Road Map",id:"constraints-and-road-map",level:2},{value:"Persistence",id:"persistence",level:4},{value:"Concurrency",id:"concurrency",level:4},{value:"Ordering",id:"ordering",level:4},{value:"Exactly Once",id:"exactly-once",level:4},{value:"Road Map",id:"road-map",level:3}],u={toc:m};function d(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Reactive programming is a declarative programming paradigm that handles asynchronous workflows in data streams.\nIf the idea is fresh to you, ",(0,o.kt)("a",{parentName:"p",href:"https://twitter.com/andrestaltz"},"@andrestaltz"),"\nhas a ",(0,o.kt)("a",{parentName:"p",href:"https://gist.github.com/staltz/868e7e9bc2a7b8c1f754"},"great article")," introducing the concept using ",(0,o.kt)("a",{parentName:"p",href:"https://reactivex.io/"},(0,o.kt)("em",{parentName:"a"},"Rx")),"."),(0,o.kt)("p",null,"The reactive paradigm naturally suits a sociable app which listens to events from chat platforms reactively.\nIt's our recommended way to control the business logic flow."),(0,o.kt)("h2",{id:"sociably-stream-package"},"Sociably Stream Package"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"@sociably/stream")," implements the reactive programming utilities that are optimized for sociable apps.\nThe most important specialty is: All the events on a chat are processed in a strict order in the stream."),(0,o.kt)("h3",{id:"install"},"Install"),(0,o.kt)("p",null,"Install the ",(0,o.kt)("inlineCode",{parentName:"p"},"@sociably/stream")," package with:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"npm install @sociably/stream\n")),(0,o.kt)("h2",{id:"usage"},"Usage"),(0,o.kt)("h3",{id:"root-stream-from-app"},"Root Stream From App"),(0,o.kt)("p",null,"Use ",(0,o.kt)("inlineCode",{parentName:"p"},"fromApp")," helper to create a stream from a Sociably app:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import Sociably from '@sociably/core';\nimport { fromApp } from '@sociably/stream';\n\nconst app = Sociably.createApp({...});\n\nconst event$ = fromApp(app);\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"event$")," stream will include all events you would receive at ",(0,o.kt)("inlineCode",{parentName:"p"},"app.onEvent()"),"."),(0,o.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"The variable name with a trailing ",(0,o.kt)("inlineCode",{parentName:"p"},"$")," is a naming convention for a stream in reactive programming."))),(0,o.kt)("h3",{id:"listen-to-a-stream"},"Listen to a Stream"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"stream.subscribe(listener, errorHandler?)")," method listens to events on a stream.\nThe listener function would receive the event context object.\nLike:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"event$.subscribe(async ({ event, reply }) => {\n  await reply(`Hello ${event.text}`);\n});\n")),(0,o.kt)("p",null,"It can also take a service container as the listener.\nLike:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import Sociably, { BasicProfiler } from '@sociably/core';\n\nevent$.subscribe(\n  makeContainer({ deps: [BasicProfiler] })(\n    (profiler) =>\n    async ({ event, reply }) => {\n      const profile = await profiler.getUserProfile(event.user);\n      await reply(<p>Hello {profile?.name || 'there'}!</p>);\n    }\n  )\n);\n")),(0,o.kt)("h3",{id:"pipe-to-a-new-stream"},"Pipe to a New Stream"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"stream.pipe(...operators)")," method pipes the stream through a series of operators that output a new stream.\nThrough it we can split the business logic into working flows,\nwhich helps us to build the app in a declarative and modular way."),(0,o.kt)("p",null,"We'll introduce some commonly used operators below."),(0,o.kt)("h3",{id:"filter-a-stream"},"Filter a Stream"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"filter(predicator)")," operator filters the stream like ",(0,o.kt)("inlineCode",{parentName:"p"},"Array.filter"),"."),(0,o.kt)("p",null,"It takes a predicator function with ",(0,o.kt)("inlineCode",{parentName:"p"},"(eventContext) => boolean")," type.\nThe event is passed to the next stream only when the predicator returnstrue`."),(0,o.kt)("p",null,"We can use it to extract a fraction of events so they can be handled separately.\nFor example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { filter } from '@sociably/stream/operators';\n\nevent$\n  .pipe(filter((ctx) => ctx.platform === 'webview'))\n  .subscribe(handleWebview);\n\nevent$\n  .pipe(filter((ctx) => ctx.event.category === 'message'))\n  .subscribe(handleMessage);\n")),(0,o.kt)("h3",{id:"map-a-stream"},"Map a Stream"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"map(transformer)")," operator shapes the events in the stream like ",(0,o.kt)("inlineCode",{parentName:"p"},"Array.map"),"."),(0,o.kt)("p",null,"It takes a transformer function with ",(0,o.kt)("inlineCode",{parentName:"p"},"(eventContext) => newContext")," type.\nThe new event context will be passed to the next stream."),(0,o.kt)("p",null,"We can use it to execute a job and attach the result onto the context.\nFor example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { makeContainer, IntentRecognizer } from '@sociably/core';\nimport { map } from '@sociably/stream/operators';\n\nconst eventWithIntent$ = event$.pipe(\n  map(\n    makeContainer({ deps: [IntentRecognizer] })(\n      (recognizer) =>\n      async (context) => {\n        const { event } = context;\n        let intent = null;\n\n        if (event.type === 'text') {\n          intent = await recognizer.detectText(event.channel, event.text);\n        }\n        \n        return { ...context, intent };\n      }\n    )\n  )\n);\n")),(0,o.kt)("h3",{id:"execute-a-side-effect"},"Execute a Side Effect"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"tap(effectFn)")," operator executes a job and then passes the original context down when it's finished."),(0,o.kt)("p",null,"The difference from ",(0,o.kt)("inlineCode",{parentName:"p"},"stream.subscribe(operator)")," is that ",(0,o.kt)("inlineCode",{parentName:"p"},"tap")," guarantees the execution order is one-by-one under a chat."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import Sociably, { makeContainer, StateController } from '@sociably/core';\nimport { tap } from '@sociably/stream/operators';\n\nevent$.pipe(\n  tap(\n    makeContainer({\n      deps: [StateController],\n    })(\n      (stateController) =>\n      async ({ event, reply }) => {\n        const count = stateController\n          .channelState(event.channel)\n          .update((curCount = 0) => curCount + 1);\n\n        await reply(<p>Hello #{count}!</p>);\n      }\n    )\n  )\n);\n")),(0,o.kt)("h3",{id:"use-asynchronized-container"},"Use Asynchronized Container"),(0,o.kt)("p",null,"The operators can take an ",(0,o.kt)("em",{parentName:"p"},"asyncronized")," function as the callback.\nAs stated, all the async jobs under a chat are executed in a strict order."),(0,o.kt)("p",null,"They also accept a ",(0,o.kt)("a",{parentName:"p",href:"/docs/dependency-injection#service-container"},"service container"),"\nof the callback function.\nAs the examples above, you can require services to handle business logic."),(0,o.kt)("h3",{id:"merge-streams"},"Merge Streams"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"merge(...streams)")," merge multiple streams into one."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { merge } from '@sociably/stream';\n\nconst greeting$ = merge(webviewGreeting$, chatGreeting$);\n")),(0,o.kt)("h2",{id:"constraints-and-road-map"},"Constraints and Road Map"),(0,o.kt)("p",null,"Currently the execution order is only guaranteed on a single server.\nIf you are running the app on a cluster,\nthe events under a chat may go to different servers and break the order."),(0,o.kt)("p",null,"To fix this, it requires an external broker to distribute the jobs and guarantee the order.\nBut there are some major challenges to overcome: "),(0,o.kt)("h4",{id:"persistence"},"Persistence"),(0,o.kt)("p",null,"Many of the Rx stream operators like ",(0,o.kt)("inlineCode",{parentName:"p"},"count")," are stateful.\nThe stream state have be stored in the database,\nso it can be recovered when the server restarts."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// the status of count have to be persistent\nconst msgCount$ = message$.pipe(count());\n")),(0,o.kt)("h4",{id:"concurrency"},"Concurrency"),(0,o.kt)("p",null,"On every process and machine,\nthe streams and operators should work identically.\nThis means the stateful operations should be safe from race conditions. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// every process should see the identical count\nconst msgCount$ = message$.pipe(count());\n")),(0,o.kt)("h4",{id:"ordering"},"Ordering"),(0,o.kt)("p",null,"The events should be processed in the same order as they are received,\neven when executing asynchronous jobs.\nThis is difficult because events could be sent to different processes."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// the mirrored messages should always be in the same order\nmessage$.pipe(\n  map(someAsyncWork),\n  map(async ({ reply, event }) =>\n    reply(event.text + '!!!')\n  )\n);\n")),(0,o.kt)("h4",{id:"exactly-once"},"Exactly Once"),(0,o.kt)("p",null,"An event should be processed exactly once in the stream,\nnot being omitted or duplicated.\nIf a server is down unexpectedly,\nthe unfinished events should be able to resume."),(0,o.kt)("h3",{id:"road-map"},"Road Map"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://kafka.apache.org/documentation/streams/"},(0,o.kt)("em",{parentName:"a"},"Kafka Stream"))," is a previous art that implements the reactive stream for server-based programs.\nIt's built upon ",(0,o.kt)("a",{parentName:"p",href:"https://kafka.apache.org/"},(0,o.kt)("em",{parentName:"a"},"Apache Kafka"))," to provide the guarantees mentioned above."),(0,o.kt)("p",null,"In the future, we'll make a similar solution in JavaScript which is based on Kafka or other brokers.\nIt'll be optimized for conversational apps, and could possibly support all the server-based programs."))}d.isMDXComponent=!0}}]);