---
title: Conversation in Script
---

Our bot can interact with users in the _Q & A_ flows now. But it can't actually
_chat_ with the user. In this lesson, you'll learn how to write scripts to guide
your bot chatting.


>ã€€Time to accomplish: 10 minutes


## What's Machinat Script?

Machinat **Script** works like a scripting language written in JSX. You describe
how a conversation should be proceeded in a script. And the script processor
would handle the conversation process according to the running script.

### Install Package

Install the `@machinat/script` packages with:

```bash
$ npm install @machinat/script
# or yarn
$ yarn add @machinat/script
```

### Building Script

Let's add our first script for adding todo in a more conversational way.
Create a `src/scenes/AddingTodo.tsx` script file like this:

```tsx title="src/scenes/AddingTodo.tsx"
import Machinat from '@machinat/core';
import { build } from '@machinat/script';

export default build(
  {
    name: 'AddingTodo',
    initVars: () => ({}),
  },
  <>
    {() => <p>Please enter new todo name:</p>}
  </>
);
```

We `build` a script with its metadata and the script body. The `name` metadata
should be unique in the whole project.

In the script body a message node is added as a function returning a message
element `{() => <p>...</p>}`. The function would be called when the node is met
in the conversation, and the returned message element would be sent.


### Register Script

Before start using, the script and the module need to be registered in your
app like this:

```ts {1-2,7-9} title="src/app.ts"
import Script from '@machinat/script';
import AddingTodo from './scenes/AddingTodo';
// ...

const app = Machinat.createApp({
  modules: [
    Script.initModule({
      libs: [AddingTodo],
    }),
  // ...
  ],
  // ...
})
```

### Delegate Chat to Processor

And edit the `main` function like this:


```ts {1,5-20,22,26} title="src/main.ts"
import Script from '@machinat/script';
// ...

const main = (event$: Stream<AppEventContext>) => {
  const chat$ = event$.pipe(
    filter((ctx): ctx is ChatEventContext => ctx.platform !== 'webview'),
    filter(
      makeContainer({ deps: [Script.Processor] })(
        (processor) => async (ctx) => {
          const runtime = await processor.continue(ctx.event.channel, ctx);
          if (!runtime) {
            return true;
          }

          await ctx.reply(runtime.output());
          return false;
        }
      )
    )
  );

  chat$
    .pipe(
      filter(
        (ctx): ctx is ChatEventContext & { event: { category: 'message' } } =>
          ctx.event.category === 'message'
      )
    )
    .subscribe(handleMessage);

  chat$
    .pipe(
      filter(
        (ctx): ctx is ChatEventContext & {
          event: { type: 'postback' | 'callback_query' };
        } =>
          ctx.event.type === 'postback' || ctx.event.type === 'callback_query'
      )
    )
    .subscribe(handlePostback);
  // ...
```

The codes we added delegate chats with running script process to the script
processor. Then the filtered `chat$` stream with no running process is handled
by the original handlers.


### Use Script

Now we can use the newly added script in the `handleMessage` function:

```tsx {1-2,10,13,23-26} title="src/handlers/handleMessage.tsx"
import Script from '@machinat/script'
import AddingTodo from '../scenes/AddingTodo';
// ...

const handleMessage = makeContainer({
  deps: [
    Machinat.BaseProfiler,
    StateController,
    TodoController,
    Script.Processor
  ] as const,
})(
  (profiler, stateController, todoController, processor) =>
    async ({
      event,
      reply,
    }: ChatEventContext & { event: { category: 'message' } }) => {
      if (event.type === 'text') {
        const matchingAddTodo = event.text.match(/add(\s+todo)?(.*)/i);
        if (matchingAddTodo) {
          const todoName = matchingAddTodo[2].trim();

          if (!todoName) {
            const runtime = await processor.start(event.channel, AddingTodo);
            return reply(runtime.output());
          }
          // ...
```

We use `processor.start(channel, script)` method to run `AddingTodo` script on
the current chat. Then reply `runtime.output()` to send the initial messages.
After that processor would take over the chat until the script is finished.

Now your bot can ask for the todo name like this:

<img width={400} src={require("./assets/add-todo-script-1.png").default} />


### `PROMPT` For Answer

The `AddingTodo` script is not actually handling answer now. We can use
the `PROMPT` keyword to achieve that.

Add the these codes in the script:

```tsx {3,5-7,12,17-23} title="src/scenes/AddingTodo.tsx"
import Machinat from '@machinat/core';
import { build } from '@machinat/script';
import { PROMPT } from '@machinat/script/keywords';

type AddingTodoVars = {
  todoName: string;
};

export default build<AddingTodoVars>(
  {
    name: 'AddingTodo',
    initVars: () => ({ todoName: '' }),
  },
  <>
    {() => <p>Please enter new todo name:</p>}

    <PROMPT<AddingTodoVars>
      key="ask-todo"
      set={({ vars }, { event }) => ({
        ...vars,
        todoName: event.type === 'text' ? event.text : '',
      })}
    />
  </>
);
```

When the `PROMPT` element is executed in the script, the following thing will
happen in order:

1. Stop point info is stored in the state.
2. Stop executing the script and wait for answer from user.
3. User reply the answer.
4. The `set` function is called for updating `vars`.
5. Continue running script from the `PROMPT`.

`vars` is a special state exists while the script is running. It is initiated by
the `initVars` function when the script starts. The `AddingTodoVars` is used
to type the `vars` in `AddingTodo` script.

`set` function receive two args: 1) a circumstance object containing current
`vars`, 2) event context of the answer message. Then we can return the next
`vars` value, set the `todoName` answer for later use.

### Execute `EFFECT`

Now we have the `todoName` answered by user, and need to save it in state like
what we do in the `handleMessage` handler.

We can add a `EFFECT` element to for that:

```tsx {2,4-5,9,15,28-39} title="src/scenes/AddingTodo.tsx"
import Machinat from '@machinat/core';
import { makeContainer } from '@machinat/core/service';
import { build } from '@machinat/script';
import { PROMPT, EFFECT } from '@machinat/script/keywords';
import TodoController from '../services/TodoController';

type AddingTodoVars = {
  todoName: string;
  todosCount: number;
};

export default build<AddingTodoVars>(
  {
    name: 'AddingTodo',
    initVars: () => ({ todoName: '', todosCount: 0 }),
  },
  <>
    {() => <p>Please enter new todo name:</p>}

    <PROMPT<AddingTodoVars>
      key="ask-todo"
      set={({ vars }, { event }) => ({
        ...vars,
        todoName: event.type === 'text' ? event.text : '',
      })}
    />

    <EFFECT<AddingTodoVars>
      set={makeContainer({ deps: [TodoController] })(
        (todoController) =>
          async ({ vars, channel }) => {
            const { data } = await todoController.addTodo(
              channel,
              vars.todoName
            );
            return { ...vars, todosCount: data.todos.length };
          }
      )}
    />
  </>
);
```

The `EFFECT` keyword can be used to execute a side effect and update the `vars`
value. Notice that we use a **service container** for the `set` prop. Almost every
functional prop of keywords can take the container version of it.

The container require `TodoController` service to save new todo, and
then set `todosCount` in the returned `vars` value.




### Message With `vars`

The message node can also get the `vars` from the circumstances and use them to
build UI. Add this message node at the end of script to show the adding result:

```tsx {1,4-8} title="src/scenes/AddingTodo.tsx"
import WithMenu from '../components/WithMenu';
// ...

    {({ vars: { todoName, todosCount } }) => (
      <WithMenu todoCount={todosCount}>
        Todo "<b>{todoName}</b>" is added!
      </WithMenu>
    )}
  </>
);
```

Now a todo can be added in a conversational way like this:

<video width={420} autoplay="autoplay" loop inline>
  <source src={require("./assets/add-todo-script-2.webm").default} type="video/webm" />
</video>


### Flow Control

We haven't verify the user input yet, so there could be a problem when user
reply a non-text message.

We can use a `WHILE` keyword to fix that:

```tsx {1,4,14} title="src/scenes/AddingTodo.tsx"
import { WHILE, PROMPT, EFFECT } from '@machinat/script/keywords';
// ...
  <>
    <WHILE<AddingTodoVars> condition={({ vars }) => vars.todoName === ''}>
      {() => <p>Please enter new todo name:</p>}

      <PROMPT<AddingTodoVars>
        key="ask-todo"
        set={({ vars }, { event }) => ({
          ...vars,
          todoName: event.type === 'text' ? event.text : '',
        })}
      />
    </WHILE>
    //...
```

`WHILE` is a flow control keyword like the `while` in programming
language. We wrap the `PROMPT` element with `WHILE`, so bot would keep asking
until the answer pass the verification.

`condition` prop control whether the loop should continue. We verify the
`vars.todoName` in the circumstances arg, and keep looping until it is a valid
string.

The result would look like:

<video width={420} autoplay="autoplay" loop inline>
  <source src={require("./assets/add-todo-script-3.webm").default} type="video/webm" />
</video>


Despite `WHILE`, there are other flow control keywords you may familiar with,
like `IF` and `RETURN`. You can control the conversation easily in the way of
programming.

### `CALL` Script

A scirpt can also be used by another script like a function call.
The `CALL` keyword instruct the runtime to execute a script, and go back to the
current point after it return.

We can use it to hint user for adding the first todo. Add a new `AskingFirstTodo`
script like this:

```tsx title="src/scenes/AskingFirstTodo.tsx"
import Machinat from '@machinat/core';
import { build } from '@machinat/script';
import { IF, THEN, PROMPT, RETURN, CALL } from '@machinat/script/keywords';
import AddingTodo from './AddingTodo';
import { ChatEventContext } from '../types';

type AskingFirstTodoVars = {
  ok: boolean;
};

export default build<AskingFirstTodoVars>(
  {
    name: 'AskingFirstTodo',
    initVars: () => ({ ok: false }),
  },
  <>
    {() => <p>You have no todo now. Do you want to create one?</p>}

    <PROMPT<AskingFirstTodoVars, ChatEventContext>
      key="ask-adding"
      set={(_, { event }) => ({
        ok: event.type === 'text'
          ? /(ok|yes|ðŸ‘Œ|ðŸ‘)/i.test(event.text)
          : false,
      })}
    />

    <IF<AskingFirstTodoVars> condition={({ vars: { ok } }) => !ok}>
      <THEN>
        {() => <p>Ok, tell me when you need.</p>}
        <RETURN />
      </THEN>
    </IF>

    <CALL key="adding-todo" script={AddingTodo} />
  </>
);
```

In the script we ask user about wether to create the first todo or not. If no,
the script simply return. If yes, call the `AddingTodo` script for the creating
process.

Then add the new script in the registered libs:

```ts {5} title="src/app.ts"
const app = Machinat.createApp({
  modules: [
    // ...
    Script.initModule({
      libs: [AddingTodo, AskingFirstTodo],
    }),
  ],
  // ...
```

Then we can use the it when a user doesn't have any todo like this:

```tsx {1,4,6-9,12} title="src/handlers/handleMessage.tsx"
import AskingFirstTodo from '../scenes/AskingFirstTodo';
// ...
    const { data } = await todoController.getTodos(event.channel);
    const helloWords = <p>Hello, {userProfile.name}! I'm a Todo Bot ðŸ¤–</p>;

    if (data.todos.length === 0) {
      const runtime = await processor.start(event.channel, AskingFirstTodo);
      return reply(runtime.output());
    }

    return reply(
        <WithMenu todoCount={data.todos.length}>{helloWords}</WithMenu>
    );
  }
);

export default handleMessage;
```

Now our bot ask user to create first todo while saying hello like this:


<video width={420} autoplay="autoplay" loop inline>
  <source src={require("./assets/hello-with-script.mp4").default} type="video/mp4" />
</video>

:::tip
Delete the `todos` data in `.state_data.json` file to try this feature.
:::

:::info
In the video above, the <img height={30} src={require("./assets/quick-replies-in-script.png").default} />
options bring better experiences when answer the question. You can check the
[complete example](https://github.com/machinat/todo-example/blob/main/src/scenes/AskingFirstTodo.tsx#L18-L36)
about how to implement.
:::

---

Now your bot can really have a chat with user according the script. Next, we'll
learn how to use a webview to provide even more features than in the chatroom.
